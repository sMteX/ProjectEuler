using System;
using System.Collections.Generic;
using System.Linq;

namespace ProjectEuler.problems
{
    public class Problem61 : Problem
    {
        List<List<int>> polygonals;
        int[] chain = new int[6];

        public void run()
        {
            /*
            Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) 
                numbers and are generated by the following formulae:

            Triangle 	  	P3,n = n(n+1)/2 	  	1, 3, 6, 10, 15, ...
            Square 	  	    P4,n = n^2 	  	        1, 4, 9, 16, 25, ...
            Pentagonal 	  	P5,n = n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
            Hexagonal 	  	P6,n = n(2n−1) 	  	    1, 6, 15, 28, 45, ...
            Heptagonal 	  	P7,n = n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
            Octagonal 	  	P8,n = n(3n−2) 	  	    1, 8, 21, 40, 65, ...

            The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
                - The set is cyclic, in that the last two digits of each number is the first two digits of the next number 
                    (including the last number with the first).
                - Each polygonal type: triangle (P3,127 = 8128), square (P4,91 = 8281), and pentagonal (P5,44 = 2882), 
                    is represented by a different number in the set.
                - This is the only set of 4-digit numbers with this property.

            Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
                triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

            - six 4 digit numbers:
                - 1000 - 9999
                - they must be cyclic = last 2 digits = first 2 digits of next
                    => last 2 digits must be > 09 => number % 100 > 9
                - each of the 6 number must be one of the figurate types => could make a histogram of the types for each number and if it's [1,1,1,1,1,1], then ok
                - they must be cyclic => there must exist a permutation of the 6 numbers that satisfy the conditions

            - instead of iterating through all 6x 4digit numbers, maybe pre-calculate all polygonal numbers and search in them
            */

            this.polygonals = new List<List<int>>() {
                generatePolygonal(3),
                generatePolygonal(4),
                generatePolygonal(5),
                generatePolygonal(6),
                generatePolygonal(7),
                generatePolygonal(8)
            };


            // try all octagonal numbers as the start of the chain, and try constructing the rest
            for (int i = 0; i < polygonals[5].Count; i++) {
                chain[5] = polygonals[5][i];
                if (findNext(last: 5, length: 1)) {
                    break;
                }
            }
            
            Func<int, int> firstTwo = (int x) => x / 100;
            Func<int, int> lastTwo = (int x) => x % 100;

            Predicate<List<int>> isCyclic = (List<int> numbers) => 
                lastTwo(numbers[0]) == firstTwo(numbers[1]) &&
                lastTwo(numbers[1]) == firstTwo(numbers[2]) &&
                lastTwo(numbers[2]) == firstTwo(numbers[3]) &&
                lastTwo(numbers[3]) == firstTwo(numbers[4]) &&
                lastTwo(numbers[4]) == firstTwo(numbers[5]) &&
                lastTwo(numbers[5]) == firstTwo(numbers[0]);

            List<int> copy = new List<int>(chain);
            foreach (var permutation in Helpers.getPermutations(copy)) {
                if (isCyclic(permutation)) {
                    break;
                }
            }

            int sum = chain.Sum();
            System.Console.WriteLine($"Sum of six 4-digit ordered cyclic set = {sum}, numbers: {string.Join(", ", copy)}");

            #region Naive, would work in infinite time
            /*
            List<int> current = new List<int>();
            bool found = false;
            List<int> result = null;

            foreach (var triangle in polygonals[3]) {
                current.Clear();
                current.Add(triangle);
                foreach (var square in polygonals[4]) {
                    if (current.Contains(square)) {
                        // each must be different
                        continue;
                    }
                    current.Add(square);

                    foreach (var pentagonal in polygonals[5]) {
                        if (current.Contains(pentagonal)) {
                            continue;
                        }
                        current.Add(pentagonal);

                        foreach (var hexagonal in polygonals[6]) {
                            if (current.Contains(hexagonal)) {
                                continue;
                            }
                            current.Add(hexagonal);

                            foreach (var heptagonal in polygonals[7]) {
                                if (current.Contains(heptagonal)) {
                                    continue;
                                }
                                current.Add(heptagonal);

                                foreach (var octagonal in polygonals[8]) {
                                    if (current.Contains(octagonal)) {
                                        continue;
                                    }
                                    current.Add(octagonal);

                                    List<int> cyclic = tryFindCyclic(current);
                                    if (cyclic != null) {
                                        found = true;
                                        result = new List<int>(cyclic);
                                        break;
                                    } else {
                                        current.Remove(octagonal);
                                    }
                                } // end octagonals
                                current.Remove(heptagonal);
                                if (found) {
                                    break;
                                }
                            } // end heptagonals
                            current.Remove(hexagonal);
                            if (found) {
                                break;
                            }
                        } // end hexagonals
                        current.Remove(pentagonal);
                        if (found) {
                            break;
                        }
                    } // end pentagonals
                    current.Remove(square);
                    if (found) {
                        break;
                    }
                } // end squares
                current.Remove(triangle);
                if (found) {
                    break;
                }
            } // end triangles
            int sum = result[0] + result[1] + result[2] + result[3] + result[4] + result[5];
            System.Console.WriteLine($"Sum of six 4-digit ordered cyclic set = {sum}, numbers: {string.Join(", ", result)}");
            */
            #endregion

        }
        private bool canChain(int x, int y) {
            return x % 100 == y / 100;
        }
        private bool findNext (int last, int length) {
            // česky možná lepší v tomto případě
            // vykradeno z https://www.mathblog.dk/project-euler-61-numbers-cyclic-property/ protože tohle bych už nevymyslel
            // řetěz v tomto případě NENÍ SEŘAZENÝ (avšak existuje permutace, ve které to je cyklická množina), takže hledáme prakticky kombinaci

            // uchováváme index (a tedy hodnotu) posledního "článku" řetězu (last) a délku řetězu (length)
            // k poslednímu článku řetězu se snažíme najít POSTUPNĚ trojúhelníkové, čtvercové, pětiúhelníkové, ... čísla
            // (za předpokladu startovního článku - osmiúhelníkového čísla) nejprve zkusíme najít trojúhelníkové číslo, které V ŘETEZU NENÍ a které se s ním DÁ SPOJIT
            // když ho najdu, zkusím k němu rekurzivně najít čtvercové číslo
            // atd. až do sedmiúhelníkového čísla
            // s tím, že na každé úrovni, pokud nenajdu pokračování, backtrackuju o úroveň zpátky a snažím se najít jiný chain

            // pokud nenajdu odpovídajícího následníka v nějaké skupině, zkusím skupinu jinou (pokud k 5. nenajdu 6., zkusím navázat 7.)
            // pokud takhle nenajdu žádného následovníka v žádné skupině, vrátím se zpět, a zkusím jiný poslední článek 
            //      (např. k trojúhelníkovému 5168 nenajdu žádné 4., 5., 6., 7. začínající 68, tak zkusím jiné trojúhelníkové 5190)
            // pokud vyčerpám i v dané skupině, zkusím další skupinu atd.
            // pokud nikde nenajdu řetěz, který by se dal použít, vrátím se úplně na začátek a zkusím jiné startovní 8. číslo

            for (int i = 0; i < chain.Length; i++) {
                if (chain[i] != 0) {
                    continue;
                }
                for (int j = 0; j < polygonals[i].Count; j++) {
                    int current = polygonals[i][j];
                    bool unique = !chain.Contains(current);
                    if (unique && canChain(chain[last], current)) {
                        chain[i] = current;
                        if (length == 5) {
                            if (canChain(chain[i], chain[5])) {
                                return true;
                            }
                        }
                        if (findNext(i, length + 1)) {
                            return true;
                        }
                    }
                }
                chain[i] = 0;
            }
            return false;
        }
        private List<int> generatePolygonal(int i) {
            List<int> numbers = null;
            if (i == 3) {
                // 40 - 140
                numbers = Enumerable.Range(45, 140-45).Select(n => n*(n+1)/2).ToList();
            } else if (i == 4) {
                // 32 - 99
                numbers = Enumerable.Range(32, 99-32).Select(n => n*n).ToList();
            } else if (i == 5) {
                // 26 - 81
                numbers = Enumerable.Range(26, 81-26).Select(n => n*(3*n-1)/2).ToList();
            } else if (i == 6) {
                // 23 - 70
                numbers = Enumerable.Range(23, 70-23).Select(n => n*(2*n-1)).ToList();
            } else if (i == 7) {
                // 21 - 63
                numbers = Enumerable.Range(21, 63-21).Select(n => n*(5*n-3)/2).ToList();
            } else if (i == 8) {
                // 19 - 58
                numbers = Enumerable.Range(19, 58-19).Select(n => n*(3*n-2)).ToList();
            }
            if (numbers != null) {
                numbers = numbers.FindAll(x => x % 100 > 9); // filter only those that don't end in 00 - 09 (which would result in cycle in 3 digit number)
            }
            return numbers;
        }
    }
}